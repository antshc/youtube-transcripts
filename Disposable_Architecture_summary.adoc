= Disposable Architecture — Summary
:toc:
:toclevels: 3
:sectnums:

== 1. Executive Summary

Цей матеріал присвячений концепції *Disposable Architecture* — архітектури, у якій компоненти, сервіси та фічі проєктуються так, щоб їх було не лише легко створити й запустити, але й *легко вимкнути, прибрати або замінити* без руйнування всієї системи.

Автори одразу відмежовують цю ідею від наївного підходу з епохи ранніх мікросервісів: «архітектура не потрібна, бо все одно перепишемо». Disposable Architecture — це не відсутність архітектури, а навпаки, більш зріла дисципліна, яка визнає тимчасовість частини рішень і робить цю тимчасовість керованою.

Ключова ідея — *планувати кінець життя фічі або сервісу ще на старті*. Якщо бізнес вирішує закрити експеримент, система повинна продовжувати працювати стабільно, без каскадних збоїв. Це досягається через низьку зв’язаність, контроль blast radius, незалежні деплої, feature flags і чіткі домовленості між технічною та продуктовою сторонами.

У результаті disposable-підхід дозволяє експериментувати швидше, зменшувати технічний борг від «мертвих» фіч і зберігати систему еволюційною, а не перевантаженою історичними артефактами.

== 2. Core Theses — Глибинні принципи

=== “Проєктуй не тільки запуск — проєктуй видалення.”

*Meaning:*  
Архітектурне рішення є повноцінним лише тоді, коли відомо, як воно буде завершене. Disposable Architecture вимагає відповіді на питання: *що станеться, якщо ми це вимкнемо або приберемо?* Видалення — такий самий сценарій, як і happy path.

*Mechanism:*  
Низька зв’язаність, контрольована деградація та ізоляція впливу дозволяють прибирати компоненти без ефекту доміно.

*Examples:*  
- Продуктова фіча, яка вимикається feature flag’ом і не ламає сторінку.  
- Backend-сервіс, відмова якого не зупиняє весь бізнес-процес.  
- Організаційне рішення: «закриваємо фічу» означає не просто сховати UI, а демонтувати залежності.

*Caution:*  
У реальних продуктах видалення завжди дорожче, ніж здається, через контракти, клієнтів та інтеграції. Без плану це стає болючим.

---

=== “Disposable ≠ відсутність архітектури.”

*Meaning:*  
Disposable Architecture — це не хаос і не «тимчасове назавжди». Це архітектура з чітким життєвим циклом, де експерименти не перетворюються на постійний тягар.

*Mechanism:*  
Коли створення й видалення однаково дешеві, технічний борг не накопичується, а експерименти стають безпечними.

*Examples:*  
- Сервіс, який швидко замінюють після невдалого експерименту.  
- Команди, які не бояться пробувати нове, бо ціна відкату контрольована.  
- Система, що продовжує працювати в деградованому режимі після вимкнення компонента.

*Caution:*  
Без дисципліни disposable-ідея швидко перетворюється на хаотичний набір напівживих рішень.

---

=== “Feature flags — це інструмент життя і смерті фічі.”

*Meaning:*  
Feature flag — не просто спосіб сховати кнопку, а механізм керування життєвим циклом фічі: запуск, експеримент, вимкнення, видалення.

*Mechanism:*  
Прапори дозволяють керувати поведінкою системи без редеплою, але потребують правил і дедлайнів.

*Examples:*  
- Швидкий kill switch у продакшені.  
- A/B-експерименти з чітким фіналом.  
- Поетапне ввімкнення та таке ж поетапне вимкнення функціоналу.

*Caution:*  
Feature flags без політики утилізації — це окремий вид технічного боргу.

---

=== “Disposable потребує стабільної перезбірки системи.”

*Meaning:*  
Щоб часто прибирати або замінювати компоненти, релізний процес має бути швидким і надійним.

*Mechanism:*  
Стабільний CI/CD, стандарти й контракти дозволяють мати короткоживучі компоненти без страху.

*Examples:*  
- Регулярна перезбірка та перевалідація компонентів.  
- Розділення фіч на experimental та core з різними вимогами.  

*Caution:*  
Без guardrails disposable-підхід перетворюється на безконтрольний «vibe coding».

== 3. Easy-Recall — Практичні інсайти

=== Best Practices
- Плануй кінець життя фічі ще до початку розробки.  
- Проєктуй низьку зв’язаність і контроль blast radius.  
- Використовуй feature flags з правилами їх видалення.  
- Чітко розділяй disposable-експерименти та core-функціонал.

=== Common Pitfalls
- Не плутай disposable з відсутністю архітектури.  
- Не залишай «вимкнені назавжди» фічі в коді.  
- Не ігноруй контракти між компонентами.

=== Rules of Thumb
- Якщо бізнес може закрити фічу — у неї має бути план демонтажу.  
- Kill path має бути таким самим продуманим, як happy path.  
- Feature flag без дедлайну = технічний борг.

== 4. Key Points with Timestamps

- [00:00–00:04] Іронічний вступ про «архітектура не потрібна».  
- [00:00:28–00:00:52] Визначення Disposable Architecture.  
- [00:02:01–00:02:33] Контекст мікросервісної ейфорії 2015 року.  
- [00:10:52–00:11:06] Ключовий критерій: вимкнення не ламає систему.  
- [00:11:06–00:12:20] Низька зв’язаність та ізоляція проблем.  
- [00:22:48–00:24:07] Планування disposable-фіч на старті.  
- [00:31:52–00:32:59] Feature flags як основний інструмент.  
- [00:49:39–00:50:17] Ризики безконтрольного експериментування.
