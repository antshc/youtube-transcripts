00:04 [Music]
00:12 thank you and it's and it's really not a joke
00:18 I do have 85 slides so I'm going to talk really fast the worst thing is that before just
00:23 before this session I was sitting outside and I was thinking I should look at this and see if I can trim it down and I added a slide
00:31 so so the thing that really interest I've I've spent my career building software systems and
00:38 mostly I tended to work at the slightly more complicated end end of things when
00:43 I was Building Systems they were usually bigger systems technically intricate for some reason high performance or whatever
00:49 else and I spent much of my career thinking of what we do as a craft and in
00:54 the latter part of my career I started to change my mind I started to think that what we do or at least how we ought
01:00 to do it should be more like engineering I think that we should take that more seriously so I want to talk a little bit
01:06 about that but specifically in the context of dealing with really complex
01:12 systems and how we undertake that and again specifically how we start to think
01:18 in terms of architecture and design on an incremental basis for systems like that so that's what my what my Talk's
01:23 about today and I'd like to start by just positioning what I mean when I'm
01:29 talking about engineering as a a discipline engineering is how we as a civilization solve the hard problems
01:35 Engineering in other disciplines is just the stuff that works if it doesn't work you change it until it works otherwise
01:40 it's not engineering so that's important the other take on this is that this is the foundation on which our civilization
01:47 is built if you think about it if you look around this room everything even the clothes I'm wearing to some degree
01:54 is an engineered artifact in the sense that I'm talking about and and so this stuff is important
02:01 here's a graph of innovation over time and you can see
02:07 there's something important H happens around there and Innovation kinds of explodes it's actually worse than that
02:14 if you go back to the you know uh pre prehistory we we've been around for
02:19 about 200,000 years and nothing very much happened for then the wheel and agricultures only about 10,000 years old
02:26 so what were people doing for all that time beforehand it's strange so what happened there is science so
02:34 science is one of the things that revolutionized our ability to do new things and more complicated things it's
02:41 our best problem solving tool and in software I think we get that
02:47 so I I would argue that modern Engineering in any field not just software modern engineering is really
02:55 about the application of scientific style reasoning to solving problems in software
03:02 and or solving problems anywhere else I think that's the nature of what modern
03:07 engineering is about it's this kind of scientifically rational approach to solving problems and I think that's the
03:13 core of what I think we ought to be thinking about in terms of Sol solving
03:19 problems in software and I think we get that wrong all of the time I think often we just treat engineering as a synonym
03:24 for software development which I don't think is is good enough and so most of us most of the IND industry isn't doing
03:32 engineering I think we ought to be but I don't think we are and then the other take on
03:38 engineering is it's hugely bureaucratic and it's not so what's engineering
03:43 really for engineering isn't a cookie cutter process that leads us to the precise right Solution that's not how it
03:50 works ever engineering is about this it's about making sure we don't do the stupid things it's about ruling out the
03:57 dumb ideas so engineering is there to help us to
04:03 avoid those bad ideas and that allows us then a spectrum of good ideas that we can choose
04:09 from and when we start thinking about genuine this is this is a picture of uh spacex's Starship um which which is the
04:18 spaceship that's supposed to take people to live on Mars one day um this is
04:23 supposed to be aimed to be the first fully reusable spacecraft two orbit and further and
04:31 back without discarding any pieces and systems like this is this is
04:36 the most complicated spacecraft that's ever been built and systems like this
04:41 don't spring fully formed from a genius's mind that's not how it works that it's a process of exploration
04:50 Discovery iteration learning and building on top of what we've learned
04:55 and and what we understand and it's always that that's what engineering is always like
05:00 and that's at the core of how we ought to organize to work in my view we should
05:07 be thinking in in those sorts of terms we should not be trying to be so preent
05:12 that we can imagine the perfect solution ahead of time so the tools of our trade are not
05:19 really things like languages and Frameworks those are just the nuts and bolts that we use to construct the things that we're
05:26 building our the tools of our trade are problem solving and design that that is that I would
05:33 argue that that's what we do for a living if we're building software and in particular what my theme
05:41 today is about incremental design because if we need to be able to start a project when we don't know the answer
05:47 yet we've got to learn and we've got to explore and we've got to build our systems incrementally to the point at
05:53 which we've got something good and that's not again not unique to us it's not special to software we have lots
05:60 advantages in software that we ought to be able to take advantage of because software is more malleable Than Physical things but apart from that this is
06:07 exactly the same as any other engineering discipline so the tools of our trade for
06:14 software engineering is design engineering I talk about this in some
06:22 detail in my book which you can buy in the stand out
06:27 there and I so I would argue that the power tools if you like of our trade are
06:33 these things in the book we I kind of analyze these things and why they matter and how they matter but if we want to
06:39 optimize for learning we need to work iteratively we need to gather feedback we need to build systems incrementally
06:45 we need to treat each change as a little experiment that we can try out our ideas and see whether they're good ideas or
06:50 bad ideas and we need to be empirical we need to measure the reality of our systems in production in use and
06:58 understand those things so that we can modify them and over time shape them to
07:04 better fit what our users want of those systems whatever that might be and part of that if we're building
07:10 complex systems is we need to deal with the complexity of those systems we are
07:16 we are at the root of our profession dealing with some genuinely complex
07:22 difficult problems ideas like distributed systems and concurrency are out there they're at the
07:31 limits of how complex information Theory and those sorts of ideas gets we're talking about genuinely first class
07:37 complicated problems here two pieces of information in different places changing at different rates which one's true
07:43 what's the state of the system that's a superposition that's that's that's that's a problem of quantum
07:50 physics so we need to figure out ways in which we compartmentalize problems to make change more safely and to do that
07:57 we need to manage the complexity so we need techniques like modular cohesion separation of concerns abstraction and managing the coupling of
08:04 our systems to be able to make progress safely in one part of the system without breaking the rest of it everywhere
08:12 else I would argue that quality in software is measured by one thing
08:18 there's one thing that's important that determines the quality of a system and that's our ability to change it of
08:23 course we want secure systems of course we want resilient systems of course we want scalable systems but how do you get
08:30 those things without being perfect first time if you can't easily change the code
08:37 so the sane thing to do is to organize our work in a way that gives us the freedom to get stuff wrong and change
08:45 our code when we learn where it's wrong so I would argue that that's what
08:50 that's another one of those things that we should focus on in order to be able to deal with these more complex systems
08:55 so how do we design and architect systems for ease of change what what do we need to do to be able to achieve
09:02 that first I think if we're going to start talking about architecture we need to talk about what software architecture
09:08 is so what do we mean by that and this is a kind of slippery idea I think this is this is wikimedia's um
09:16 sorry Wikipedia's uh description software architecture is a set of structures needed to reason about
09:21 Software System and the discipline of creating such structures and systems I think the interesting part of that definition is this needed to reason
09:28 about architecture again is not a constraining fixed set of rules or
09:35 things like that it's a way in which we can reason about the system a good
09:41 architecture is one where all of the team members would come to roughly the same kind of idea of a solution given
09:47 the context of a new feature you know yeah we should think that would feature would live in this service over here or
09:53 we should organize that this way or that one doesn't fit our architecture we will have to think again more deeply those
09:59 are the kinds of convers ations that you want from an architecture so I again I would AR argue
10:07 that there's no big distinction between architecture design and code I see them as being on a Continuum and part of the
10:14 reason for that is that I can make a change a tiny change in code that breaks
10:20 the architecture of the system I can make a tiny change in the architecture that makes it impossible to write the
10:25 code to to to fulfill something so there's this kind of feedback loop here
10:30 that that's in play and so the only sane thing as as far as I can see to do this
10:36 is to adopt the practice of a kind of continuous approach to architecture architecture is not a static thing it's
10:43 not a thing that a bunch of brilliant people in an ivory Tower doing isolation
10:48 Before We Begin work and then we follow that those rules as though they were written written in stone for the rest of
10:54 the project that's not how it works we need a more evolution approach
10:60 to architecture and any real complex system that you look at has
11:06 changed usually dramatically at some point throughout its life it's evolved
11:11 think of something as relatively straightforward as as an iPhone the first iPhone didn't have an app store it
11:18 didn't have um it didn't have cameras it certainly didn't have an AI thing in it
11:24 um all of you know all of these things were were novel and new they came later and I'm sure that the original designers
11:31 had some vision of where it might go but I'm also certain that they didn't get it exactly right I'm also certain that they
11:37 didn't know what a modern iPhone would be like compared to the original products whatever they are
11:44 evolve over time and get better over time if they're good
11:49 products so architecture is less like this some kind of prescriptive model of
11:55 what we're talking about and to my mind it's more like this a kind of tourist
12:01 map this is not geographically accurate the the the topology is right but the
12:06 the distance measures are going to be wrong but I can find my way to the
12:13 crocodiles so this this kind of idea of architecture as a sort of snapshot
12:18 tourist map of our picture accurate in some directions but not precise in
12:23 all I think is's a good one I think I I like this idea as a way of thinking about architecture
12:33 perhaps one of the deepest most fundamental ideas to get good at this is this idea of iteration and I would argue
12:40 that this is absolutely foundational and fundamental to almost any process of engineering we we're always talking
12:47 about being able to make changes and continue the changes and flow those changes through the system this is the
12:54 uh the first heavier than air controlled powered man carrying aircraft all of
12:59 those caveats are you need because there were versions of aircraft that had one
13:05 or of those things but this is the first one that brought them all together flew in 1903 it's the right flyer and these
13:11 things were death traps they were so dangerous that for about the next 20 years the pioneers of Aviation nearly
13:18 all got killed by the things that they were pioneering in so what happened in aviation in
13:24 engineering was that after each accident or mistake or you know after each
13:30 implementation of a new aircraft they learned things and they did better next time by the time of the second world war
13:37 they they were building things like this this is a DC3 this is the first passenger carrying air airplane that
13:43 looks vaguely like a passenger carrying airplane to us now um it has the the
13:48 kind of the monocot fuselage the the windows in the side and the passengers in a row in this
13:53 tube um and then we get to something like this
13:59 and in 2017 the equivalent of 2third of the population of the planet flew in
14:05 commercial airliners and nobody died that's the first time that ever happened that's what engineering does
14:12 that's iteration on a very slow scale but that's what engineering always does it makes things better and better and
14:18 safer and safer over time because engineering is about doing the things that work and if they don't work we
14:23 change things the idea of iteration is important and it's vitally important to
14:29 being build in building complex systems in software so the idea for for iteration is really that we're going to
14:35 find some St some starting points and we've got some goal that we imagine that we'd like to achieve and to get to that
14:41 goal all we need is a fitness function that's able to to determine whether our
14:47 idea gets us closer to the goal or further away so we can try something out say no that's no good it's getting us
14:53 further away so I'll discard that and then we can try something else out and
14:58 even if we do this at random them we can try stuff out and see what gets us nearer to the goal the keynote this
15:04 morning was talking about artificial in intelligence and large and and deep neural networks this is how deep neural
15:09 networks work this is how learning works this is an evolutionary approach to learning so we can we can use this as a
15:16 tool for ourselves when we're talking about these
15:21 these little experiments these little Fitness functions it's more difficult in software to see what they are because
15:27 it's not obvious what the measurements are but in this case we can use tests as those measurements we can specify what
15:33 it is that we want of our software and validate whether each change moves Us in the direction of making all the test
15:39 pass or not validating that we're getting closer to our goal or further from our
15:47 goal so how do we use these power tools um I I'd like you to just pause for a
15:54 moment and look at these 10 things imagine two versions of the system that you're working on or one that you're
15:60 very familiar with and imagine one in which there's no iteration no feedback there's no incremental development no
16:07 experimental approach to learning things no empirical discovery about whether the product's working in production or
16:13 not okay now imagine another version where you've got all of those things which project would you rather work on
16:19 the second one right now imagine do the same thing with the things on the right imagine a system
16:26 there there's no modularity no cohesion no separation of concerns no abstraction really and terrible coupling we even
16:32 have a name for those we call them big balls and mud now imagine the counter where you've
16:39 got nice modular code where you can change it in one place and it doesn't infect another all of the bits that are
16:44 relevant are together in the code so that when you're looking at one part of the code you can see what's going on in
16:49 that narrow context each part of the system is divided up so that each part is focused on doing one job and doing
16:56 that well and that the lines between those parts are well abstracted so that we can interact with another part of the
17:02 system without knowing or caring about the details of how that works these are all markers of quality in the design of
17:10 systems and we work to manage and reduce the coupling where we can between those
17:15 parts so that they're easy to change now imagine those two versions of the system as well the big ball of mud
17:21 or the modular cohesive system with good separation of curs which one of those would you rather working it's the second
17:27 one again right so those are those are goals those are
17:33 things if we have those characteristics in our systems those are the
17:38 characteristics that will make it easier to change those systems and therefore markers of the quality of those systems
17:44 there's a bunch of techniques that can help with those so we make work in small steps that allows us to be more
17:49 iterative we prioritize testability architecture as a snapshot maintain the tourist map and all of these things I
17:55 want to go through each of these and just show how they map to the 10 things so I'm just going to whiz through uh
18:01 we're doing all right for time so far so let's start with small
18:10 steps so small steps enable all of these things if we make a small change it's
18:16 going to it's going to work better if we if we're working iteratively that's going to encourage us to to to make a
18:22 small step and evaluate where we are gathering feedback to understand where we are working incrementally building
18:27 the system on top of each each stable point that we've achieved with our small step so making progress in these small
18:34 steps is profoundly important and allows us to learn more quickly and more effectively we're building on more
18:42 concrete knowledge we know that this system works because all of our test pass and we haven't and our changes
18:48 haven't broken anything that's a good
18:53 thing taking small steps gives us the freedom to be wrong it improves our feedback it gives us more opportunities
18:59 to learn I said that increases our confidence in the system it also reduces risk because each change is Tiny and
19:06 therefore lower risk so we can move much more quickly and much more effectively if we can do these things and it reduces
19:13 costs because we're not risking I'll come back to that but we're not risking really expensive changes if we're making
19:21 progress in smaller steps so big steps are a bad idea so you
19:26 know if you're planning six months wor worth of work what can go wrong well you
19:32 could be wrong 6 months worth of work could be a waste so we could try something and we
19:39 miss and we spend all of this money and then we could try something else and we miss and we spend all of this money and
19:46 we end up spending lots of money and and taking lots of time and getting nowhere that's that's certainly possible I don't
19:52 know about you but I've certainly worked on projects that felt like that on the other hand if we make Tiny
20:00 Steps our investment is smaller so we we we reduced our risk and if we're measuring against our fitness function
20:07 whether we're closer to the goal or further from the goal after each one we can validate each one and understand
20:12 where we are so we can try that that didn't work out so we spent some money but not very much we can try that and
20:18 and so we we end up that's what I mean by reducing costs in terms of working this way this is a much more
20:25 economically efficient as well as technically efficient way of building complex systems we increase the
20:32 visibility of our systems uh the change is simpler because each step is simpler
20:37 and the reasoning about the system is simpler of course we need the big picture as well we need to be holding these models in our head and having our
20:43 tourist maps to guide us to understand where we are in our architecture but
20:49 that these small steps give us the opportunity to better control the variables and on it kind of not just
20:56 give us the opportunity it kind of applies a pressure on us to encourage us to make sure that we better control the
21:02 variables and understand the impact of each small
21:09 step so next in our list prioritize
21:14 testability so this is a picture this is a picture that I stole from I think it's a Wikipedia picture again um but it's
21:22 it's a description of the scientific method and a key part of the scientific method is this de testable predictions
21:30 if my hypo hypothesis is correct then I expect this to be true if I if I want to
21:38 be able to pay by credit card then I expect that if I go and select this book from the shelf and pay by credit card I
21:44 own the book at the end that that's that's a that's an experiment that's a testable prediction
21:51 so if we organize our work around the testability of our systems we get loads of huge
21:57 benefits again we improve the feedback we were allowed to work more incrementally more experimentally and we
22:03 it tends to encourage us to build more modular more cohesive systems with better separation of concerns all of
22:09 those good things here's an example of that kind of
22:17 specification so this is this is taken from the
22:23 Cucumber website this is a a classic example I now I don't like this very much because
22:29 um this is not really specifying what we want this is mixing together the specification in the
22:34 implementation so I'd slightly change this I I'd change these to say when I
22:40 add 50 to 70 the result should be 120 that's a simple specification it's hasn't lost any information at all about
22:47 the the specification of the problem this is still accurate but now I can Implement that anyway I like I no longer
22:54 have to have a screen I no longer have to have buttons to push or any of those sorts of things because those things aren't mentioned
22:59 so by specifying things in the abstract from the perspective of a user and prioritizing the use of a specification
23:06 to Define what we want of our software then we now have a tool that we
23:11 can use to evaluate whether we're making an appropriate small step if I make this test pass I've made a small step in the
23:18 direction of something that's going to be valuable presumably to our users we can we'll learn about that later
23:25 probably this is a perhaps say more realistic kind of
23:34 specification and you can see this is this is saying nothing at all about the implementation detail but everything
23:40 about what we need to achieve what the user needs to achieve with the software that we're going to deliver to them and
23:45 we're coming up with these specifications based on examples that would demonstrate that the feature that we care about
23:56 exists here's another example so this is just as true for um what are commonly
24:04 called the non-functional requirements like lots of people I assume in this room I hate that term these aren't non-functional
24:11 requirements because users care about these just as much as they care about anything else these are just requirements the reason the only reason
24:17 I think that we bother to separate them from other kinds of requirements is because these are harder to plan and
24:23 project managers therefore don't like them that's a problem because these are just as important as the ones that that
24:28 are easy plan but these things matter but we can use the same Technique we can specify the outcome that we want in this
24:35 case we'd like our system to respond in a in a timely manner and this is for something like a trading system this is
24:42 absolutely business critical this is not something separate this is not something distinct this is not a technical need
24:49 this is a business need and that's true too and that's true of all non-functional requirements I would
24:55 argue you can always find the real requirement hiding in there
25:01 somewhere next architecture as a snapshot architecture needs to be this
25:06 kind of living thing so at the as the the the life of our software progresses
25:12 we're going to say well that's our current architecture and then oh we we we need to scale up a little bit so
25:18 we're going to change the things around a little bit and now this is our current architecture and then we need to scale
25:25 that bit up as well so this is our new current architecture and that's how
25:30 architecture always works if it's static it's dead if we're going to build complex
25:37 systems we're not going to get them right first time so we must have the freedom to be able to change them to
25:43 evolve them to step by step incrementally build them up and and so
25:49 architecture is always only a snapshot of what it was Amazon started out as a
25:55 PHP application it's not that anymore it's very very very different indeed
26:01 because it had to because it was limiting the scalability of the business it was limiting what they could do with
26:06 it that's true for all of the systems that we use that are
26:13 successful so if we work using architecture as a snapshot that allows us to optimize for learning once again
26:19 it allows us to amp up all of these properties that are that we consider to
26:25 be of value evolutionary architecture then is
26:31 important we need to think about it in these terms this isn't a nice East nice to have this isn't an esoteric thing
26:37 that's on the edge this is at the core of what we do for a living or it should be this is how we build great systems we
26:45 allow ourselves the freedom to not get everything right first time and potentially to be wrong and the idea is
26:52 is that we'll discover where we're wrong or where as we learn more we'll understand the problem better and be
26:57 better able to Sol solve it so we allow ourselves the freedom to be able to do that so we make progress in small steps
27:05 we the architecture is only ever true at a moment in time it's always this
27:11 snapshot and if we can't change it as I said it's already dead next on the
27:18 list in order to be able to facilitate that we've got to maintain our tourist map at even though our tourist map is
27:25 vague and imprecise there are going to be times when it'll still end up needing to change to be wrong so in in the case
27:32 of our our tourist map of the zoo we could change things we could add things to it if we are able to do that that's
27:39 going to amplify all of these things iteration feedback incremental and experimental working and it's going to
27:45 up modularity cohesion separation of concerns abstraction and coupling as as a side effect of being able to model the
27:52 system and think about how it's organized at the level the high level of
27:57 abstraction of a tourist map the value of the tourist map is that
28:03 we want it to be a little intentionally a little bit vague so that we've got room to change without invalidating
28:08 everything that we've written about it and everything that we described it
28:14 with so prioritizing ease of change is really what continuous deliver is for so
28:21 so so deployment pipelines are were were designed to optimize the process of
28:27 giving us that really fast feedback back and giving us this experimental platform where we can try out our ideas get fast
28:33 feedback on them and see whether they're valid or not so continuous delivery is the best
28:39 tool for us to be able to prioritize the ease of change of these systems that encourages us to do all of those things
28:45 in terms of managing complexity because the easiest kinds of systems to continuously deliver are systems that
28:51 are modular cohesive good separation of concerns um nice clean lines of
28:58 abstraction and minimize coupling because we can test them more
29:06 efficiently continuous delivery gives gives the optimize for learning thing um
29:12 and optimizing for manage complexity but that's via the testability so so that's
29:18 it's kind of a s the modularity the sorry man the properties of managing complexity come as a kind of side effect
29:25 of the way of working with continuous delivery continuous delivery just works more easily with systems that work
29:32 nicely separation separate concerns this is another one of those core ideas it's
29:37 been around for a very long time if you look at the solid principles there's quite a lot of the solid principles that
29:42 are really just are really talking about separation of concerns this is a big deal so if we've got something that's
29:49 doing process and store it's going to be much better if we separate it out as process and store as separate pieces
30:01 so this is going to up uh managing complexity metrics and it's going to
30:06 amplify feedback incremental and experimental working so optimizing our ability to learn if we've got those
30:12 kinds of those those things in
30:19 place adapt to the current context so this is again about working with the
30:25 current version of the system not our imag imaginary Future Vision of it there's Kent Beck described it as yagy
30:33 in in the extreme programming book but you ain't going to need it so we're going to work on what we know to be true
30:39 now but we're going to design things with a way where we kind of leave the door open so that we've got room to
30:45 change things when when we find out what we really ought to be doing later on so
30:51 if we start out with a simple story like this customer place order we can probably implement that with a simple
30:57 system like this and then as the next story comes along
31:02 add new products we probably need something new new now we need to add some admin facilities and the ability to
31:08 have some inventory and all of those kinds of things to allow us to do that and that's our new architecture and then
31:15 we re architect again to be res more resilient in the face of failures when we're in use and we our user Bas is
31:21 building and this what all the big web companies did they didn't start out with
31:27 globally scalable system systems they started out with simple systems and then they made them globally scalable later on and this is so we need to adapt to
31:34 the current context the problem that we have in front of us right now and we need to engineer to solve that problem
31:41 but we need to engineer to solve that problem in a way that maintains our ability to change the system in
31:49 future if we do that that optimizes for Learning and all of these kinds of things and then that is enabled by
31:57 designing using the techniques of managing complexity I hope that what you're
32:03 starting to see there's this kind of Tangled nest of relationships between
32:09 these ideas and practices and these properties that we value in software development practice the optimizing for
32:16 Learning and software development design techniques the the optimizing for
32:21 complexity ideas these are not independent things they're all part of this ecosystem of doing a better job
32:29 which is I I think a good description of what engineering might might be described as the other one of those things is that
32:36 we don't want to be designing ahead um so if we start off with the same place order and we and we do this
32:44 and build the whole system as we imagine that it would be that's a bad idea because we might be wrong we might never
32:50 get the users we might have spent a load of time building all of this complicated scalable
32:55 system and we might end end up with five users I once worked on a trading system
33:01 that was bu and we were brought in to speed it up and we started working to speed it up and said what do we think
33:07 the user load is he said well we've got three at the moment so so what were we doing wouldn't
33:13 it be better to be doing on something that would get more users so we start with the simple thing
33:21 and then we we change the simple thing we don't try and predict where we're going to be but we try and work in ways
33:26 that don't close off the doors we're not going to build aead we're not going to design ahead but we are going
33:32 to try and design carefully with the properties of modularity cohesion separation concerns and so on so that
33:38 our system will be easy to change when we find out what we ought to be doing so once
33:45 again the techniques of managing complexity enable our ability to design ahead when to avoid designing
33:57 ahead platform as abstraction there's a lot of stuff talked about platform
34:02 engineering these days and I think that's both wonderful and
34:08 risky that there there are some naive views about what platform engineering is so platform let's first just rule out
34:15 the the some of the dumb ideas platform engineering doesn't mean offloading um how to talk to the cloud
34:23 to some group of cloud Specialists that's not it so platform
34:28 engineering is about taking cognitive load away from the teams that are building features that are of value to
34:35 users so as part of platform engineering you need to understand quite deeply the
34:41 whole problem I would argue that platform engineering is just a modern way of talking about good
34:47 design so platform engineer but it's also a great tool you don't want every person on the team worrying about the
34:55 intricacies of building secure system or scalable systems or something all of the
35:01 time for every feature but you do need the people that are building the platforms that we rely
35:06 on to make our systems more secure more scalable more resilient to understand the context in which they matter
35:12 platforms should be focused primarily on reducing that reducing that cognitive
35:17 load with respect to um stream aligned
35:24 teams so platform is is best as an abstraction but it's kind of focused on
35:30 on on that those those kinds of outcomes and again a platform as an abstraction
35:35 when we get this right it does these things it helps us to manage the complexity better and it optimizes for
35:40 learning more effectively last in my list is managing
35:50 coupling so we could write software like this where we have some complex thing and all sorts of different interactions
35:56 with that complex systems h up everybody who's seen a system like this yeah it's very very common much
36:05 better is to try and minimize the coupling to a sensible degree I don't
36:11 mean purely abstract and completely divorced coupling is always going to be there if you want these pieces to
36:17 interact so we minimize the coupling so that the conversations are sensible conversations one of the techniques that
36:24 I tend to use for that is that I I'm I'm I'm a big fan of domain driven design so
36:29 I try to aim to make sure that the conversations between significant parts of my system different Services different modules of my system at a C
36:37 scale are kind of recognizable as business level conversations if you showed the conversation map of the
36:43 messages that flowed in the system to a domain expert they'd understand what was going on that's a decent level of
36:49 abstraction that kind of starts to move in the direction of a slightly more abstract conversation between these
36:55 pieces and again if we start to ad those techniques and start to minimize the
36:60 coupling in that way then we amplify our ability to do all of these things to change our software more effectively
37:07 through the the managing the complexity and to give ourselves the chance to learn and to try things out if we get
37:12 the cup if we get the the abstraction wrong the coupling wrong between two pieces of software we want to be able to
37:19 discover that quickly and then change
37:25 it so I would AR argue that software development is exploration and Discovery and
37:33 Engineering is the best way to explore and
37:41 discover so software and architecture are best when engineered is my argument
37:48 thank you very much I hope you have a great conference