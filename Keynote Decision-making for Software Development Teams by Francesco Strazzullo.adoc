= Decision-Making for Software Development Teams â€“ Francesco Strazzullo (NDC 2025)
:toc:
:toclevels: 3

== 1. Executive Summary

Francesco Strazzulloâ€™s keynote explores the *hidden art and science of decision-making* in software development.  
Developers make countless choices dailyâ€”languages, frameworks, architectures, cloud vendorsâ€”but often do so unconsciously and without structured reasoning.  
His central argument: **technical excellence requires disciplined decision-making just as much as coding skill.**

He highlights how teams often practice coding but not *decision-making*, leading to arbitrary or biased choices that impact long-term maintainability, scalability, and cost.  
To fix this, Francesco introduces a structured, *shared decision-making process* â€” involving the right people, gathering data, identifying non-functional requirements (â€œthe -ilitiesâ€), and comparing solutions analytically.

The talk advocates visualization tools such as *interest-power maps*, *architecture compasses*, and *weighted ranking charts* to make reasoning transparent and collective.  
He stresses that decision quality depends on *context awareness* â€” business priorities, team skills, software lifecycle stage (explore, expand, extract), and user characteristics.

Finally, he emphasizes clear delegation: who makes which decisions and how reversible they are.  
Teams must align on *authority levels* (e.g., consultative, democratic, or autonomous) to avoid confusion and endless debates.  
His conclusion: **mindful, transparent decision-making turns technical discussions into strategic engineering.**

== 2. Core Theses

=== â€œDevelopers make decisions constantly â€” but rarely practice decision-making.â€
*Main argument:* Every code change is a decision (choice of framework, pattern, or architecture). Yet few teams deliberately train this skill.  
*Explanation:* We train for syntax, algorithms, and testingâ€”but not structured choice-making. Without awareness, we default to habits, biases, or â€œwhat we know best.â€  
*Example:* Choosing microservices because â€œitâ€™s trendy,â€ without evaluating team maturity, leads to maintenance chaos later.

=== â€œDefine and share a decision-making process within your team.â€
*Main argument:* A repeatable process reduces chaos and emotional bias.  
*Process steps:*
1. Involve the right people.  
2. Gather relevant data (business, user, technical).  
3. Define critical non-functional requirements.  
4. Generate and compare options analytically.  
*Example:* Before selecting a cloud provider, ensure that architects, DevOps, security officers, and cost owners are all included.

=== â€œVisualize decisions â€” pictures outlive meetings.â€
*Main argument:* Humans remember visuals, not meeting notes.  
*Example:* Use charts, diagrams, or Miro boards summarizing architectural trade-offs. Visuals keep alignment even months later and prevent â€œdecision amnesia.â€

=== â€œInvolve the right people â€” but know who they are.â€
*Main argument:* Many teams donâ€™t even know their stakeholders.  
*Method:* Map roles on an *interest-power grid*:  
- High power, low interest â†’ e.g., CTOs (need periodic input)  
- High interest, low power â†’ e.g., customer support (need constant feedback)  
*Example:* If changing cloud providers affects cost and uptime, include finance and operations early.

=== â€œDecisions depend on context â€” business, users, and lifecycle.â€
*Business needs:* Understand the *why* of your product.  
Example: If your appâ€™s key value is â€œspeed and usability,â€ allocate budget to UX and native mobile performance.  
*User context:* Elderly users treat bugs as â€œbroken devices,â€ while teens expect glitches.  
Example: For older audiences, prioritize reliability over new features.  
*Lifecycle:* Apply *Freaks Model* (Explore â†’ Expand â†’ Extract).  
- In â€œexplore,â€ speed and validation matter more than scalability or polish.  
- In â€œextract,â€ optimization and quality dominate.

=== â€œNon-functional requirements (the â€˜-ilitiesâ€™) guide architectural choices.â€
*Main argument:* Functionality tells *what* to build; non-functional requirements (NFRs) tell *how* to build it.  
*Example:* â€œProcess payments in under 2 secondsâ€ influences architecture, performance, and language choice far more than the functional spec â€œadd checkout button.â€  
*Method:*  
- Pick 4â€“6 most critical NFRs.  
- Define a shared meaning (e.g., â€œScalability = handle 2Ã— traffic with â‰¤20% latency increaseâ€).  
- Visualize using an *Architecture Compass* â€” showing trade-offs among usability, maintainability, scalability, etc.

=== â€œCompare options analytically, not emotionally.â€
*Two methods:*
- *Visual comparison charts* (quick shape-based trade-off mapping).  
- *Weighted ranking matrix* (quantitative scoring of options by NFR importance).  
*Example:* Compare â€œSpring Boot,â€ â€œPhoenix,â€ and â€œLaravelâ€ frameworks. Each is scored on performance, maintainability, learning curve, etc. The result justifies the final choice transparently.

=== â€œDecisions need ownership and delegation clarity.â€
*Main argument:* Conflict often arises not from *what* we decide, but *who* decides.  
*Tool:* *Delegation Board (E. Appelo)* â€” defines levels from â€œTellâ€ (leader decides) to â€œDelegateâ€ (team decides).  
*Guideline:*  
- Use â€œAgreeâ€ (consensus) for high-impact, irreversible decisions.  
- Use â€œDelegateâ€ for reversible, low-risk technical choices.  
*Example:* Architecture changes â†’ collective decision. Logging library version â†’ team autonomy.

=== â€œReversibility defines urgency and authority.â€
*Main argument:* The more reversible a decision, the more decentralized it can be.  
*Example:* Choosing a new color scheme â†’ reversible â†’ delegate to team.  
Choosing a database vendor â†’ irreversible â†’ needs higher-level alignment.

== 3. Easy-Recall Section

=== âœ… Best Practices
- Define a *shared decision-making process* with steps and roles.  
- Always identify whoâ€™s impacted before deciding.  
- Use *visual tools* â€” charts, maps, diagrams â€” to document outcomes.  
- Choose 4â€“6 *non-functional requirements* and align on their meaning.  
- Compare options with *quantitative scoring* or visual trade-off maps.  
- Match decisions to *business lifecycle* (donâ€™t over-engineer in the explore phase).  
- Revisit decisions when context changes â€” process is iterative.

=== âŒ Donâ€™ts
- Donâ€™t make architectural choices in isolation.  
- Donâ€™t skip user or business input â€” code exists for outcomes, not elegance.  
- Donâ€™t confuse speed with progress: a quick wrong decision costs more later.  
- Donâ€™t let every meeting end in â€œagreeâ€ mode â€” define authority upfront.  
- Donâ€™t assume â€œhigh qualityâ€ is always the goal â€” context matters.

=== âš–ï¸ Rules of Thumb
- *Decision quality > decision speed* (except in explore-phase experiments).  
- *If everything is a priority, nothing is.* Pick few NFRs.  
- *If a decision is reversible, make it fast; if irreversible, make it slow and deliberate.*  
- *The bigger the ripple, the broader the stakeholder circle.*  
- *Visual artifacts outlive memory.*

=== ğŸ’¡ Pros / Cons of Structured Decision-Making
|===
| **Pros** | **Cons / Challenges**

| Clear accountability | Requires facilitation effort
| Shared understanding | Initial overhead in setup
| Objective comparisons | Harder in rapidly changing projects
| Easier onboarding for new devs | Can feel bureaucratic if overused
|===

== 4. Key Points with Timestamps

|===
| Time | Insight

| *00:03â€“02:18* | Developers make constant decisions, often unconsciously â€” from frameworks to deployment models.
| *02:58â€“04:17* | We practice coding, not decision-making â€” most choices are implicit and habitual.
| *05:05â€“06:38* | Start by defining a shared decision-making process; tailor it to your organization.
| *06:45â€“07:25* | Visualize outcomes â€” drawings and diagrams retain collective memory better than meeting notes.
| *07:33â€“09:48* | Identify stakeholders via â€œinterest-powerâ€ mapping to ensure proper involvement.
| *10:02â€“12:58* | Gather business context: use â€œelevator pitchâ€ and â€œtrade-off slidersâ€ to align on priorities.
| *15:31â€“17:22* | Apply Freaks Model: software evolves from *explore â†’ expand â†’ extract*; match decisions to lifecycle.
| *19:04â€“21:16* | Team skill mapping prevents unrealistic technology choices.
| *21:28â€“23:38* | UX research reveals tolerance to bugs â€” older vs younger users differ dramatically.
| *24:05â€“26:04* | Non-functional requirements define *how* software should behave â€” the â€œ-ilities.â€
| *26:36â€“29:23* | Adding a simple performance constraint (â€œin <2 secondsâ€) transforms a vague story into a concrete engineering goal.
| *29:37â€“31:31* | Choose only 4â€“6 NFRs; define shared meanings (â€œubiquitous languageâ€).
| *31:37â€“33:31* | Use an *architecture compass* to visualize trade-offs (durability, extensibility, usability, etc.).
| *34:06â€“38:17* | Compare solutions visually or with *weighted ranking* for transparency and traceability.
| *39:38â€“41:45* | Clarify decision ownership using Delegation Board (levels from Tell â†’ Delegate).
| *41:09â€“42:17* | Map reversibility vs impact; use â€œagreeâ€ only when truly necessary.
| *42:18â€“43:09* | Wrap-up: mindful, structured decision-making transforms technical debates into professional collaboration.
|===
